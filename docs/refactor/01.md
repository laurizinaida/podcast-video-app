好的，Winston在此。

我们已经完成了对整个项目的全面审计。现在，我将为您提供一份**全面、完整且统一的修改方案**。这份方案旨在将项目当前的代码实现与我们最终确定的v2.9版《全栈架构文档》完全对齐。

请按照以下步骤操作，这将解决您在本地开发环境中遇到的所有认证和数据库访问问题。

-----

### **第一步：删除错误实现的文件**

为了彻底根除错误的架构模式，请首先删除以下文件。这些文件代表了`dev` agent对“独立后端服务”的错误理解。

1.  **删除代理登录路由：**
      * **文件路径：** `apps/web/src/app/api/auth/login/route.ts`
      * **原因：** 我们的架构中，登录逻辑完全由 `[...nextauth]` 路由处理，不需要这个代理。

-----

### **第二步：修正核心认证逻辑**

这是解决本地数据库访问问题的核心。我们将修正`Auth.js`的初始化方式，使其能够在Cloudflare的边缘环境中动态获取数据库绑定。

1.  **修正 `apps/web/src/lib/auth.ts`**

      * **目的：** 这个文件将不再尝试静态地初始化`NextAuth`，而是导出一个可复用的配置生成函数`getConfig`。
      * **完整替换内容：**
        ```typescript
        import NextAuth from "next-auth"
        import Credentials from "next-auth/providers/credentials"
        import Google from "next-auth/providers/google"
        import type { NextAuthConfig } from "next-auth"
        import bcrypt from 'bcryptjs';
        import { User } from '@podcast-video-app/shared/types/user';
        import { D1Database } from '@cloudflare/workers-types';
        import { D1Adapter } from "@auth/d1-adapter";

        // 导出一个可复用的配置生成函数
        export const getConfig = (db: D1Database): NextAuthConfig => {
          return {
            // @ts-ignore // D1Adapter is compatible
            adapter: D1Adapter(db),
            providers: [
              Google({
                clientId: process.env.GOOGLE_CLIENT_ID,
                clientSecret: process.env.GOOGLE_CLIENT_SECRET,
              }),
              Credentials({
                name: "credentials",
                credentials: {
                  email: { label: "Email", type: "email" },
                  password: { label: "Password", type: "password" }
                },
                async authorize(credentials) {
                  if (!credentials?.email || !credentials?.password) {
                    return null;
                  }

                  if (!db) {
                    console.error("Database binding is not available in authorize function.");
                    throw new Error("Database not available.");
                  }

                  try {
                    const userFromDb = await db.prepare('SELECT * FROM Users WHERE email = ?1')
                      .bind(credentials.email)
                      .first<User & { password_hash: string }>();

                    if (!userFromDb || !userFromDb.password_hash) {
                      return null; // 用户不存在或没有设置密码
                    }

                    const isValidPassword = await bcrypt.compare(
                      credentials.password as string, 
                      userFromDb.password_hash
                    );

                    if (!isValidPassword) {
                      return null; // 密码错误
                    }

                    // 返回的用户对象将用于创建会话
                    return {
                      id: userFromDb.id,
                      name: userFromDb.name,
                      email: userFromDb.email,
                    };
                  } catch (error) {
                    console.error('Authorize error:', error);
                    return null;
                  }
                }
              })
            ],
            pages: {
              signIn: '/auth/login',
            },
            callbacks: {
              async jwt({ token, user }) {
                if (user) {
                  token.id = user.id;
                }
                return token;
              },
              async session({ session, token }) {
                if (token && session.user) {
                  session.user.id = token.id as string;
                }
                return session;
              },
            },
            session: {
              strategy: "jwt",
              maxAge: 24 * 60 * 60, // 24 hours
            },
            secret: process.env.AUTH_SECRET,
          }
        }
        ```

2.  **修正 `apps/web/src/app/api/auth/[...nextauth]/route.ts`**

      * **目的：** 这个文件将负责在每次请求时，动态地获取Cloudflare运行时环境，并用它来初始化`NextAuth`。
      * **完整替换内容：**
        ```typescript
        import NextAuth from "next-auth"
        import { getConfig } from "@/lib/auth"
        import { getRequestContext } from '@cloudflare/next-on-pages';

        // 动态创建处理器
        const handler = (req: Request, res: Response) => {
            // 关键步骤：在请求上下文中获取Cloudflare的运行时环境
            const context = getRequestContext();
            const env = context.env as any;

            // 从环境中提取D1数据库绑定
            const db = env.DB;

            // 将数据库绑定传入配置函数，并动态初始化NextAuth
            // 这确保了每次认证操作都能访问到数据库
            // @ts-ignore
            return NextAuth(req, res, getConfig(db));
        }

        export { handler as GET, handler as POST }
        ```

-----

### **第三步：修正前端服务与UI逻辑**

1.  **修正 `apps/web/src/services/authService.ts`**

      * **目的：** 简化注册逻辑，使其不再错误地在注册后调用`login`。
      * **完整替换内容：**
        ```typescript
        import { apiClient } from './apiClient';
        import { User } from '@/packages/shared/types/user';
        import { signIn, signOut, getSession } from 'next-auth/react';

        export type RegisterCredentials = Omit<User, 'id' | 'createdAt' | 'passwordHash'>;
        export type LoginCredentials = Pick<User, 'email' | 'password'>;

        export async function register(credentials: RegisterCredentials): Promise<User> {
          const response = await apiClient.post('/auth/register', credentials);
          // 在v2.9架构下，注册成功后，我们应该引导用户去登录页面
          return response.user;
        }

        export async function login(credentials: LoginCredentials): Promise<User> {
          const result = await signIn('credentials', {
            redirect: false,
            email: credentials.email,
            password: credentials.password,
          });

          if (result?.error) {
            // NextAuth 在 authorize 返回 null 时，会在此处抛出错误
            throw new Error('Invalid email or password');
          }

          // 登录成功后，重新获取会话以确保拿到最新的用户信息
          const session = await getSession();
          if (!session?.user) {
            throw new Error('Login successful, but failed to retrieve session.');
          }
          return session.user as User;
        }

        export async function logout(): Promise<void> {
          await signOut({ redirect: true, callbackUrl: '/auth/login' });
        }

        export async function getMe(): Promise<User | null> {
          const session = await getSession();
          return session?.user as User | null;
        }
        ```

2.  **修正 `apps/web/src/components/auth/RegisterForm.tsx`**

      * **目的：** 在用户成功注册后，将其导航到登录页面，而不是直接进入仪表盘。
      * **完整替换内容：**
        ```typescript
        'use client';

        import * as React from 'react';
        import { useForm } from 'react-hook-form';
        import { zodResolver } from '@hookform/resolvers/zod';
        import * as z from 'zod';
        import { Button } from '@/components/ui/button';
        import { Input } from '@/components/ui/input';
        import { useAuthStore } from '@/stores/authStore';
        import { useRouter } from 'next/navigation';

        const registerFormSchema = z.object({
          name: z.string().min(2, { message: 'Name must be at least 2 characters.' }),
          email: z.string().email({ message: 'Please enter a valid email.' }),
          password: z.string().min(8, { message: 'Password must be at least 8 characters.' }),
        });

        type RegisterFormValues = z.infer<typeof registerFormSchema>;

        export function RegisterForm() {
          const router = useRouter();
          const { register, status } = useAuthStore();
          const [error, setError] = React.useState<string | null>(null);

          const {
            register: formRegister,
            handleSubmit,
            formState: { errors },
          } = useForm<RegisterFormValues>({
            resolver: zodResolver(registerFormSchema),
          });

          const onSubmit = async (data: RegisterFormValues) => {
            setError(null);
            try {
              await register(data);
              // 注册成功后，导航到登录页面
              router.push('/auth/login');
            } catch (err: any) {
              setError(err.message || 'An unexpected error occurred.');
            }
          };

          return (
            <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
              <div className="space-y-2">
                <label htmlFor="name">Name</label>
                <Input id="name" {...formRegister('name')} />
                {errors.name && <p className="text-sm text-red-500">{errors.name.message}</p>}
              </div>
              <div className="space-y-2">
                <label htmlFor="email">Email</label>
                <Input id="email" type="email" {...formRegister('email')} />
                {errors.email && <p className="text-sm text-red-500">{errors.email.message}</p>}
              </div>
              <div className="space-y-2">
                <label htmlFor="password">Password</label>
                <Input id="password" type="password" {...formRegister('password')} />
                {errors.password && <p className="text-sm text-red-500">{errors.password.message}</p>}
              </div>
              {error && <p className="text-sm text-red-500">{error}</p>}
              <Button type="submit" disabled={status === 'loading'} className="w-full">
                {status === 'loading' ? 'Registering...' : 'Register'}
              </Button>
            </form>
          );
        }
        ```

-----

### **第四步：修正项目文档**

1.  **修正 `README.md`**

      * **目的：** 使`README.md`与最终的架构文档完全一致，消除关于Hono和独立API的错误信息。

      * **完整替换内容：**

        ```markdown
        # 智能化在线视频创作平台

        一个基于Next.js和Cloudflare的全栈应用，旨在帮助播客主和音频创作者轻松地将其音频内容转化为动态、风格化的视频。

        ## 技术栈

        本项目采用一体化的全栈架构，代码库为Monorepo结构。

        * **核心框架:** Next.js 15 (App Router)
        * **部署环境:** Cloudflare Pages & Workers
        * **数据库:** Cloudflare D1
        * **对象存储:** Cloudflare R2
        * **身份认证:** Auth.js (NextAuth)
        * **UI:** Tailwind CSS, Radix UI
        * **开发工具:** Turborepo, pnpm, Playwright, Vitest

        详细信息请参考 `docs/architecture.md`。

        ## 项目结构

        ```

        podcast-video-app/
        ├── apps/
        │   ├── web/        \# 唯一的、完整的Next.js全栈应用
        │   └── renderer/   \# 独立的视频渲染应用 (Python)
        ├── packages/
        │   ├── shared/     \# 跨应用共享的代码
        │   └── config/     \# 共享的配置文件
        └── docs/             \# 项目文档

        ````
        
        ## 本地开发

        ### 环境要求
        - Node.js 20+
        - pnpm 9+
        - Cloudflare CLI (wrangler)

        ### 安装与启动
        ```bash
        # 1. 安装依赖
        pnpm install

        # 2. 配置环境变量
        cp apps/web/.env.example apps/web/.env
        # ... 编辑 .env 文件 ...

        # 3. 创建本地D1/R2资源
        # (请参考 wrangler.toml 和 architecture.md)

        # 4. 启动开发服务器
        pnpm dev:wrangler
        ````

        开发服务器将通过Wrangler启动，模拟Cloudflare环境，地址为 `http://localhost:8788`。

        ### 测试

        ```bash
        # 运行所有测试
        pnpm test
        ```

        ```
        
        ```

-----

### **第五步：验证**

在完成以上所有文件的修改和删除后，请执行以下步骤进行验证：

1.  **重新启动开发服务器：**
    ```bash
    pnpm dev:wrangler
    ```
2.  **运行E2E测试：**
    ```bash
    pnpm test:e2e
    ```
    您的E2E测试 应该能够顺利通过，因为它覆盖了完整的注册、登出和重新登录流程。

完成这些步骤后，您的项目将完全符合我们的架构设计，并且能够在本地环境中顺畅地进行开发和测试。